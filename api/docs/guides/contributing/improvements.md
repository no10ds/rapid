# Future Features

This section describes improvements that have been suggested as the rAPId service evolves.

## API Gateway Integration

### Problem

All redirections and security checks are being done inside the application. Also, we do not have a way to easily
implement a "central hub" that talks to several rAPId instances.

### Suggested solution

Using an API Gateway system such as [Kong](https://konghq.com/partners/aws/) to handle redirections and security checks
in Cognito.

### Considerations

#### AWS API Gateway

We tried to implement the AWS API Gateway to solve this issue since it was easy to set up. However, it has a lot of
limitations such as the max payload (10Mb)
. [AWS API Gateway Limits](https://docs.aws.amazon.com/apigateway/latest/developerguide/limits.html)

#### Kong Gateway

We suggest Kong since it has a free version, brings a lot of customization and can be implemented in AWS without too
much trouble.

## Trace requests

### Problem

Currently, there is not enough visibility for the application requests in the logs. We can find any error, but it would
be better if we could trace the steps that had been made before it, and gather information on whoever made a request.

Implementing a tracing functionality will reduce the risk of having any repudiation issues in the application.

### Suggested Solution

There several ways to do this, however, we recommend following one of these:

1) Use a request id generated by the API Gateway (If one is implemented), this would give visibility on every level, and
   would allow the people supporting the app to know if a request has reached the server or if it got any communication
   issues before, then it can be logged at the start of each step to trace visibility on what is happening. The API
   Gateway might have the functionality to log information such as the IP address, therefore, we should be able to track
   exactly who made a particular request at any given time
2) Generate a UUID at the start of every request. Again, we can log it at the start of every step is made in the
   application and trace the whole journey for any given request. There could also be a log that links any request to
   whoever is making it

## One Infrastructure Configuration per Block

### Problem

When instantiating the infrastructure for a department, specific configuration should be provided to determine what is
the rapid service domain, which is the S3 bucket to store date, etc.

Currently, this is done by one configuration file located at the repository `rapid-infrastructure-config` or another
configuration file informed by the user. Therefore, one file concentrates all the config parameters which are later sent
to each infra terraform block.

Due to that each block receives more parameters than it needs since one file contains all of them.

### Suggested solution

In order to solve this problem, one approach is to have multiple config files focused on the respective terraform block
plus a common terraform config file.

Instead of having one file called `input-params.tfvars`, this can be broken down as:

* `common-params.tfvars` => contains parameters that are common by 2 or more blocks
* `auth-params.tfvars` => specific parameters for authentication block with cognito
* `app-cluster.tfvars` => specific parameters for app-cluster module
* etc.

For each block, the terraform command invocation also needs to change, so it can call 2 configuration files. See example
below:

`terraform apply /location/app-cluster/main.tf -var-file=/location/common-params.tfvars -var-file=/location/app-cluster.tfvars`

## Exception Handling and HTTP Status Codes

### Problem

Currently, our custom exceptions are defined with a status code, this pollutes application logic with the HTTP layer

### Suggested solution

Ideally we pull up assigning the status codes into the global exception handler, which already determines whether to
return json or redirect a user.

## Session timeout in 2+ tabs

### Problem
If the user has the application opened in 2+ tabs and leaves 1 idle while works in another, the logout process will be
triggered, thus ending the session also on the tab that the user is working on and making the user to re-authenticate.

### Suggested solution
Store the timeout time in the local storage, create an interval that checks every second if the timeout has been
reached and update the time everytime a user does an action in any of the tabs.

## Running the app locally needs the rat cookie from the real app

### Problem
Since we need to use the `DOMAIN_NAME` in order to connect to our auth systems, we need to get a valid cookie from the
real application in order to run the app locally. Thus making our journey test fail if tried to run in the local app.
Also, locally we run the app in http, but we have some of our endpoint hardcoded to https making the application break
when trying to authenticate. Finally, Cognito is not aware of localhost as a possible login/logout url so any request
with localhost will fail.

### Suggested solution
Separate the domain name and the auth domain name into different variables and dynamically assign http or https for then
auth urls. Finally, change the default infra to allow localhost as a login/logout redirect url
